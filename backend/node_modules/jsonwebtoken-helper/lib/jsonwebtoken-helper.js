"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var jwt = __importStar(require("jsonwebtoken"));
var AuthorizedAlgorithms;
(function (AuthorizedAlgorithms) {
    AuthorizedAlgorithms["HS256"] = "HS256";
    AuthorizedAlgorithms["HS384"] = "HS384";
    AuthorizedAlgorithms["HS512"] = "HS512";
    AuthorizedAlgorithms["RS256"] = "RS256";
    AuthorizedAlgorithms["RS384"] = "RS384";
    AuthorizedAlgorithms["RS512"] = "RS512";
    AuthorizedAlgorithms["ES256"] = "ES256";
    AuthorizedAlgorithms["ES384"] = "ES384";
    AuthorizedAlgorithms["ES512"] = "ES512";
})(AuthorizedAlgorithms || (AuthorizedAlgorithms = {}));
var JwtHelper = (function () {
    function JwtHelper() {
    }
    JwtHelper.parseFromEnv = function () {
        var _a = process.env, JWT_ALGORITHM = _a.JWT_ALGORITHM, JWT_DEFAULT_EXPIRES = _a.JWT_DEFAULT_EXPIRES, JWT_ISSUER = _a.JWT_ISSUER, JWT_KEY_IDS = _a.JWT_KEY_IDS, JWT_SECRET_SEPARATOR = _a.JWT_SECRET_SEPARATOR, JWT_SECRET_TOKEN = _a.JWT_SECRET_TOKEN;
        if (!JWT_KEY_IDS || !JWT_ISSUER || !JWT_SECRET_SEPARATOR || !JWT_SECRET_TOKEN) {
            throw new Error('You must be provide these environement variables: ' +
                'JWT_SECRET_SEPARATOR, JWT_SECRET_TOKEN, JWT_KEY_IDS, JWT_ISSUER');
        }
        var defaultExpire = undefined;
        if (JWT_DEFAULT_EXPIRES) {
            if (/^\d+$/.test(JWT_DEFAULT_EXPIRES)) {
                defaultExpire = parseInt(JWT_DEFAULT_EXPIRES, 10);
            }
            else {
                defaultExpire = JWT_DEFAULT_EXPIRES;
            }
        }
        this._HEADER = [];
        this._SECRET = {};
        var keyIds = JWT_KEY_IDS.split(JWT_SECRET_SEPARATOR);
        var secrets = JWT_SECRET_TOKEN.split(JWT_SECRET_SEPARATOR);
        if (secrets.length !== keyIds.length) {
            throw new Error('Please provide the same .');
        }
        for (var i = 0; i < keyIds.length; i += 1) {
            var keyId = keyIds[i] || this._DEFAULT_NO_KEY_ID;
            this._SECRET[keyId] = secrets[i];
            var header = {
                algorithm: JWT_ALGORITHM,
                expiresIn: defaultExpire,
                issuer: JWT_ISSUER,
                keyid: keyId,
            };
            if (!JWT_ALGORITHM) {
                delete header.algorithm;
            }
            if (!JWT_DEFAULT_EXPIRES) {
                delete header.expiresIn;
            }
            this._HEADER.push(header);
        }
    };
    JwtHelper.sign = function (payload) {
        this.init();
        var keys = Object.keys(this._SECRET);
        var lastKey = keys[keys.length - 1];
        return jwt.sign(payload, this._SECRET[lastKey || this.NO_KEY_ID], this.getHeader(lastKey));
    };
    JwtHelper.verify = function (payload) {
        this.init();
        var payloadKeyId = this.getKeyId(payload);
        var options = this.getHeader(payloadKeyId) || {};
        var opts = __assign({}, options, { complete: true });
        return jwt.verify(payload, this._SECRET[payloadKeyId], opts, function (error, decrypted) {
            if (error) {
                throw error;
            }
            var header = decrypted.header, toReturn = decrypted.payload;
            if (header) {
                if (header.kid && header.kid === opts.keyid) {
                    return toReturn;
                }
                if (!header.kid) {
                    return toReturn;
                }
                throw new jwt.JsonWebTokenError("jwt keyid invalid. expected: " + opts.keyid);
            }
            return undefined;
        });
    };
    JwtHelper.getKeyId = function (payload) {
        var decrypted = jwt.decode(payload, { complete: true });
        if (decrypted && decrypted.header && decrypted.header.kid) {
            return decrypted.header.kid;
        }
        return this._DEFAULT_NO_KEY_ID;
    };
    JwtHelper.getHeader = function (keyId) {
        this.init();
        return this._HEADER.find(function (_a) {
            var kid = _a.keyid;
            return kid === keyId;
        });
    };
    JwtHelper.init = function () {
        if (!this._HAS_PARSED) {
            this.parseFromEnv();
        }
        this._HAS_PARSED = true;
    };
    JwtHelper.getHeaders = function () {
        this.init();
        return this._HEADER;
    };
    JwtHelper.getSecrets = function () {
        this.init();
        return this._SECRET;
    };
    Object.defineProperty(JwtHelper, "NO_KEY_ID", {
        get: function () {
            return this._DEFAULT_NO_KEY_ID;
        },
        enumerable: true,
        configurable: true
    });
    JwtHelper._DEFAULT_NO_KEY_ID = 'noKeyId';
    return JwtHelper;
}());
exports.default = JwtHelper;
//# sourceMappingURL=jsonwebtoken-helper.js.map